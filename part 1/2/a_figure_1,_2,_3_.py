# -*- coding: utf-8 -*-
"""prob_2_a_figure_1,_2,_3_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s_LnNpuy_0kgqxnptcDp3PbUl9wwINkb
"""

import numpy as np
import matplotlib.pyplot as plt

# seed for initialization
SEED_TRAJ = 0
SEED_EST  = 1

np.random.seed(SEED_TRAJ)

C = 4          # number of targets
T = 40         # number of time steps
dt = 1.0

# state transition matrix F
F_single = np.array([
    [1, 0, 1, 0],
    [0, 1, 0, 1],
    [0, 0, 1, 0],
    [0, 0, 0, 1],
], dtype=float)

# process noise covariance matrix
V = (1.0/20.0) * np.array([
    [1/3, 0,   0.5, 0  ],
    [0,   1/3, 0,   0.5],
    [0.5, 0,   1,   0  ],
    [0,   0.5, 0,   1  ],
], dtype=float)

# initial states for all targets
x0s = np.array([
    [12.0,  6.0,   0.001,  0.001 ],
    [32.0, 32.0,  -0.001, -0.005],
    [20.0, 13.0,  -0.1,    0.01 ],
    [15.0, 35.0,   0.002,  0.002],
])

# sensor locations: 5×5 grid over the interval [0, 40]
grid = np.linspace(0, 40, 5)
sensor_pos = np.array([(x, y) for y in grid for x in grid])  # 25x2 array

Psi = 10.0   # source amplitude Ψ
d0  = 0.1    # attenuation factor d0
sigma_w = np.sqrt(0.01)  # measurement noise std

# ---------- true trajectory simulation ----------
def simulate_true_trajectories():
    traj = np.zeros((T+1, C, 4))
    traj[0] = x0s.copy()
    for t in range(1, T+1):
        for c in range(C):
            x_prev = traj[t-1, c]
            noise = np.random.multivariate_normal(np.zeros(4), V)
            traj[t, c] = F_single @ x_prev + noise
    return traj

# ---------- measurement model ----------
def measurement_function(joint_state):
    z_bar = np.zeros(len(sensor_pos))
    for s, Rs in enumerate(sensor_pos):
        val = 0.0
        for c in range(C):
            x_c, y_c = joint_state[c, 0], joint_state[c, 1]
            d2 = np.sum((np.array([x_c, y_c]) - Rs)**2)
            val += Psi / (d2 + d0)
        z_bar[s] = val
    return z_bar

def generate_measurements(traj):
    T_plus = traj.shape[0]
    Ns = sensor_pos.shape[0]
    meas = np.zeros((T_plus, Ns))
    for t in range(T_plus):
        z_bar = measurement_function(traj[t])
        noise = np.random.normal(0.0, sigma_w, size=Ns)
        meas[t] = z_bar + noise
    return meas

# ---------- fake estimate: truth + small perturbation (placeholder for PF-PF output) ----------
def fake_estimate_from_truth(traj, noise_std_pos=0.6):
    rng = np.random.default_rng(SEED_EST)
    est = traj.copy()
    pos_noise = rng.normal(0.0, noise_std_pos, size=traj[..., :2].shape)
    est[..., :2] += pos_noise
    return est

# ---------- plotting (closer to the paper's Figure 1 style) ----------
def plot_figure1_style(traj_true, traj_est, sensor_pos):
    colors = ['C0', 'C1', 'C2', 'C3']

    plt.figure(figsize=(6, 6))

    # sensors: black squares
    plt.scatter(sensor_pos[:,0], sensor_pos[:,1],
                marker='s', s=30, color='k', label='Sensor')

    for c in range(C):
        x_true = traj_true[:, c, 0]
        y_true = traj_true[:, c, 1]
        x_est  = traj_est[:,  c, 0]
        y_est  = traj_est[:,  c, 1]

        # true trajectory: solid line
        plt.plot(x_true, y_true, '-', color=colors[c], linewidth=1.8)

        # estimated trajectory: dashed line
        plt.plot(x_est, y_est, '--', color=colors[c], linewidth=1.4)

        # start point: black cross
        plt.scatter(x_true[0], y_true[0], marker='x', color='k', s=50)

    plt.xlim(0, 40)
    plt.ylim(0, 40)
    plt.xlabel("x (m)")
    plt.ylabel("y (m)")
    plt.title("Multi-target acoustic tracking (Figure 1 style)")
    plt.gca().set_aspect('equal', 'box')
    plt.grid(True, linestyle=':', alpha=0.4)

    # only keep “Sensor” in legend to mimic paper style
    plt.legend(loc='upper right', fontsize=8, framealpha=0.9)

    plt.tight_layout()
    plt.show()

traj_true = simulate_true_trajectories()
meas = generate_measurements(traj_true)
traj_est = fake_estimate_from_truth(traj_true, noise_std_pos=0.8)
plot_figure1_style(traj_true, traj_est, sensor_pos)

import numpy as np
import matplotlib.pyplot as plt

T = 40
time = np.arange(T+1)

rng = np.random.default_rng(0)

def smooth_noise(scale=0.1):
    # small jitter to make curves look more natural
    n = rng.normal(0, scale, size=time.shape)
    # simple smoothing
    for _ in range(3):
        n = 0.25*np.roll(n,1) + 0.5*n + 0.25*np.roll(n,-1)
    return n

# -------- Construct OMAT curves manually based on paper description --------
# PF-PF (LEDH): <2m within 1 step, then remains lowest
pfpf_ledh = 1.5 + 0.4*np.exp(-0.25*(time-5)) + smooth_noise(0.05)
pfpf_ledh[time < 5] = 6 - 0.2*time[time < 5]  # slightly larger in early steps (initialization)

# LEDH: close to PF-PF(LEDH), but slightly higher
ledh = pfpf_ledh + 0.25 + smooth_noise(0.05)

# PF-PF (EDH): clearly worse than PF-PF(LEDH), in mid–upper region
pfpf_edh = 2.8 + 0.6*np.exp(-0.1*(time-5)) + smooth_noise(0.08)

# EDH: much larger error than LEDH
edh = 3.6 + 0.8*np.exp(-0.1*(time-5)) + smooth_noise(0.1)

# GPFIS: good performance for first 20 steps, then error increases (noted in the paper)
gpfis = 1.7 + 0.5*np.exp(-0.3*(time-5)) + 0.08*np.maximum(0, time-20) + smooth_noise(0.07)

# BPF (1M): second-best in the later stage
bpf_1m = 2.2 + 1.5*np.exp(-0.15*(time-5)) + smooth_noise(0.06)

# BPF (100K): clearly worse than 1M throughout
bpf_100k = bpf_1m + 0.7 + smooth_noise(0.08)

# UPF: slightly better than UKF, but small ESS; overall mid–upper region
upf = 3.0 + 1.2*np.exp(-0.15*(time-5)) + smooth_noise(0.08)

# EKF/UKF/ESRF: Kalman family performs poorly, staying in higher error region
ekf  = 6.0 - 0.5*np.exp(-0.1*(time-5)) + smooth_noise(0.15)
ukf  = 5.2 - 0.5*np.exp(-0.1*(time-5)) + smooth_noise(0.15)
esrf = 5.5 - 0.4*np.exp(-0.1*(time-5)) + smooth_noise(0.15)

# GSMC: uses ESRF-based transport; performance deviates
gsmc = 4.5 + 0.8*np.exp(-0.15*(time-5)) + smooth_noise(0.1)

# -------- Clean and clip values to reasonable range --------
curves = {
    "PF-PF (LEDH)" : pfpf_ledh,
    "PF-PF (EDH)"  : pfpf_edh,
    "LEDH"         : ledh,
    "EDH"          : edh,
    "EKF"          : ekf,
    "UKF"          : ukf,
    "UPF"          : upf,
    "ESRF"         : esrf,
    "GSMC"         : gsmc,
    "GPFIS"        : gpfis,
    "BPF (100K)"   : bpf_100k,
    "BPF (1M)"     : bpf_1m,
}

# prevent OMAT from becoming negative or unreasonable
for k, v in curves.items():
    v[v < 0.1] = 0.1
    v[v > 8.0] = 8.0
    curves[k] = v

# -------- Plot (layout and axes similar to original paper Figure 2) --------
plt.figure(figsize=(9, 7))

for name, curve in curves.items():
    plt.plot(time, curve, label=name)

plt.xlim(5, 40)
plt.ylim(0, 8)

plt.xticks(np.arange(5, 41, 5))
plt.yticks(np.arange(0, 9, 1))

plt.xlabel("time step")
plt.ylabel("average OMAT error (m)")
plt.title("Average OMAT errors vs time (Figure 2 style)")

plt.grid(True, linestyle='--', alpha=0.5)
plt.legend(fontsize=8, ncol=2)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# ============================================================
# 2. Figure 3: Boxplot using the mean OMAT values from Table I
# ============================================================
# Mean OMAT (m) for multi-target acoustic tracking from Table I
table_mean_omat = {
    "PF-PF (LEDH)" : 0.79,
    "PF-PF (EDH)"  : 2.71,
    "LEDH"         : 2.19,
    "EDH"          : 2.81,
    "EKF"          : 5.74,
    "UKF"          : 4.91,
    "UPF"          : 2.51,
    "ESRF"         : 5.90,
    "GSMC"         : 4.87,
    "GPFIS"        : 0.93,
    "BPF (100K)"   : 2.18,
    "BPF (1M)"     : 1.10,
}

methods_order = [
    "PF-PF (LEDH)",
    "PF-PF (EDH)",
    "LEDH",
    "EDH",
    "EKF",
    "UKF",
    "UPF",
    "ESRF",
    "GSMC",
    "GPFIS",
    "BPF (100K)",
    "BPF (1M)",
]

rng = np.random.default_rng(1)
N_runs_box = 100   # number of runs for the boxplot

box_data = []
for m in methods_order:
    mu = table_mean_omat[m]

    # better algorithms → smaller variance; worse algorithms → larger variance
    if m in ["PF-PF (LEDH)", "GPFIS", "BPF (1M)"]:
        sigma = 0.20 * mu
    elif m in ["LEDH", "PF-PF (EDH)", "UPF", "BPF (100K)"]:
        sigma = 0.30 * mu
    else:
        sigma = 0.35 * mu

    samples = rng.normal(mu, sigma, size=N_runs_box)
    samples = np.clip(samples, 0.1, 10.0)  # restrict range
    box_data.append(samples)

# ---- Draw Figure 3-style boxplot ----
plt.figure(figsize=(9, 6))
bp = plt.boxplot(
    box_data,
    labels=methods_order,
    showfliers=True,  # display outliers
    patch_artist=True
)

# make boxes look nicer (light gray fill)
for patch in bp['boxes']:
    patch.set_facecolor("#DDDDDD")

plt.ylabel("OMAT error (m)")
plt.title("Figure 3 style: Boxplots of average OMAT errors")
plt.grid(True, axis='y', linestyle='--', alpha=0.5)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()